# ~/.bashrc - Main bash configuration

###################
# Shell Options
###################
shopt -s histappend      # Append to history, don't overwrite
shopt -s checkwinsize    # Update LINES and COLUMNS after each command
shopt -s cdspell         # Autocorrect typos in cd
shopt -s dirspell        # Autocorrect typos in directory names
shopt -s globstar        # Enable ** for recursive globbing
shopt -s nocaseglob      # Case-insensitive globbing

###################
# History
###################
HISTSIZE=10000
HISTFILESIZE=20000
HISTTIMEFORMAT="%F %T  "
HISTCONTROL=ignoreboth:erasedups

###################
# Prompt
###################
# Git branch in prompt (if in a repo)
parse_git_branch() {
    git branch 2>/dev/null | sed -n 's/^\* \(.*\)/ (\1)/p'
}

# Colorful prompt with git branch
export PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[33m\]$(parse_git_branch)\[\033[00m\]\$ '

###################
# Environment
###################
export EDITOR=vim
export VISUAL=vim
export CLICOLOR=1
export LSCOLORS=GxFxCxDxBxegedabagaced

# Less options
export LESS='-R --quit-if-one-screen'

###################
# Path Additions
###################
# Add local bin if it exists
if [ -d "$HOME/bin" ]; then
    export PATH="$HOME/bin:$PATH"
fi
if [ -d "$HOME/bin/gd-scripts" ]; then
    export PATH="$HOME/bin/gd-scripts:$PATH"
fi

if [ -d "$HOME/.local/bin" ]; then
    export PATH="$HOME/.local/bin:$PATH"
fi
if [ -d "$HOME/.bash_functions.d" ]; then
    export PATH="$HOME/.bash_functions.d:$PATH"
fi

###################
# Aliases - General
###################
alias ll='ls -lah'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

# Safety nets
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Shortcuts
alias c='clear'
alias h='history'
alias j='jobs -l'
alias path='echo -e ${PATH//:/\\n}'
alias now='date +"%Y-%m-%d %H:%M:%S"'

# Grep with color
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

###################
# Aliases - Git
###################
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'
alias gco='git checkout'
alias gb='git branch'
alias glog='git log --oneline --graph --decorate -20'

###################
# Aliases - Docker
###################
alias d='docker'
alias dc='docker compose'
alias dps='docker ps'
alias dpsa='docker ps -a'
alias di='docker images'
alias dlog='docker logs -f'
alias dexec='docker exec -it'
alias dclean='docker system prune -af'

###################
# Aliases - Network Hosts
###################
# Add your local network hosts here
# alias pi='ssh pi@192.168.1.50'
# alias nas='ssh admin@192.168.1.100'

###################
# Aliases - GCP/Work
###################
alias gcloud-auth='gcloud auth login && gcloud auth application-default login'
alias k='kubectl'
alias kgp='kubectl get pods'
alias kgs='kubectl get services'
alias kgd='kubectl get deployments'
alias klog='kubectl logs -f'

###################
# Functions
###################

# Make directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Extract any archive
extract() {
    if [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"    ;;
            *.tar.gz)    tar xzf "$1"    ;;
            *.tar.xz)    tar xJf "$1"    ;;
            *.bz2)       bunzip2 "$1"    ;;
            *.rar)       unrar x "$1"    ;;
            *.gz)        gunzip "$1"     ;;
            *.tar)       tar xf "$1"     ;;
            *.tbz2)      tar xjf "$1"    ;;
            *.tgz)       tar xzf "$1"    ;;
            *.zip)       unzip "$1"      ;;
            *.Z)         uncompress "$1" ;;
            *.7z)        7z x "$1"       ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Create a timestamped backup of a file
backup() {
    if [ -f "$1" ]; then
        cp "$1" "${1}.backup.$(date +%Y%m%d_%H%M%S)"
        echo "Backup created: ${1}.backup.$(date +%Y%m%d_%H%M%S)"
    else
        echo "File not found: $1"
    fi
}

# Quick find file
ff() {
    find . -type f -iname "*$1*" 2>/dev/null
}

# Quick find directory
fd() {
    find . -type d -iname "*$1*" 2>/dev/null
}

# Show disk usage of current directory
usage() {
    du -sh "${1:-.}"/* 2>/dev/null | sort -h
}

# SCP to multiple destinations (from your Linux setup)
scp_to_both() {
    if [ $# -eq 0 ]; then
        echo "Error: No files specified"
        echo "Usage: scp_to_both <file(s)>"
        return 1
    fi

    local files=("$@")
    local file_count=0

    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            ((file_count++))
        fi
    done

    if [ $file_count -eq 0 ]; then
        echo "Error: No matching files found"
        return 1
    fi

    echo "Found $file_count file(s) to copy"

    echo "Copying to niwot..."
    scp "${files[@]}" niwot: || echo "Failed to copy to niwot"

    echo "Copying to homey..."
    scp "${files[@]}" homey:/mnt/usb-ssd/nmf-vs-mackalls/ || echo "Failed to copy to homey"

    echo "Done!"
}

###################
# Google Cloud SDK
###################
if [ -f "$HOME/google-cloud-sdk/path.bash.inc" ]; then
    source "$HOME/google-cloud-sdk/path.bash.inc"
fi

if [ -f "$HOME/google-cloud-sdk/completion.bash.inc" ]; then
    source "$HOME/google-cloud-sdk/completion.bash.inc"
fi

###################
# Node Version Manager
###################
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && source "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && source "$NVM_DIR/bash_completion"

###################
# Local Customizations
###################
# Source local bashrc if it exists (for machine-specific settings)
if [ -f ~/.bashrc.local ]; then
    source ~/.bashrc.local
fi

set -o vi
function dates() {
    date +%s
}
export -f dates
function fenc() {
    fenc.sh "$@"
}
export -f fenc
alias sbrc="source $HOME/.bashrc"
alias zipc='zipc.sh'

for f in ~/dotfiles/bash_functions.d/*.sh; do
    source "$f"
done
function cleanScreenshots(){
    \rm ~/Desktop/Screenshot*
}
# Claude Conversation Converter
# Add this to your ~/.bashrc or ~/.bash_profile
#
# Dependencies:
#   pip install reportlab  (only needed for PDF output)
#
# Usage:
#   claude-conv input.txt                     # -> input_conversation.pdf
#   claude-conv input.txt output.pdf          # explicit output
#   claude-conv input.txt output.md           # markdown output
#   claude-conv input.txt -f md               # markdown, auto filename
#   claude-conv input.txt -f pdf -t "Title"   # PDF with title

# Set this to where you put the Python script
CLAUDE_CONV_SCRIPT="${HOME}/bin/claude_conv_to_pdf.py"

claude-conv() {
    if [[ ! -f "${CLAUDE_CONV_SCRIPT}" ]]; then
        echo "Error: Claude converter script not found at ${CLAUDE_CONV_SCRIPT}"
        echo "Update CLAUDE_CONV_SCRIPT in your bashrc to point to the script location."
        return 1
    fi

    if [[ $# -eq 0 ]]; then
        echo "Usage: claude-conv <input.txt> [output.pdf|output.md] [-f pdf|md] [-t title]"
        echo ""
        echo "Convert Claude conversation exports to PDF or Markdown."
        echo ""
        echo "Options:"
        echo "  -f, --format    Output format: pdf or md (overrides extension)"
        echo "  -t, --title     Document title"
        echo ""
        echo "Examples:"
        echo "  claude-conv chat.txt                    # -> chat_conversation.pdf"
        echo "  claude-conv chat.txt notes.md           # -> notes.md (markdown)"
        echo "  claude-conv chat.txt -f md              # -> chat_conversation.md"
        echo "  claude-conv chat.txt -t 'Project Chat'  # PDF with custom title"
        return 0
    fi

    python3 "${CLAUDE_CONV_SCRIPT}" "$@"
}

# Optional: tab completion for the function
_claude_conv_completions() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    case "${prev}" in
        -f|--format)
            COMPREPLY=($(compgen -W "pdf md markdown" -- "${cur}"))
            return 0
            ;;
        -t|--title)
            # No completion for title
            return 0
            ;;
    esac

    if [[ "${cur}" == -* ]]; then
        COMPREPLY=($(compgen -W "-f --format -t --title -h --help" -- "${cur}"))
    else
        # Complete filenames
        COMPREPLY=($(compgen -f -- "${cur}"))
    fi
}

complete -F _claude_conv_completions claude-conv
eval "$(pyenv init -)"
